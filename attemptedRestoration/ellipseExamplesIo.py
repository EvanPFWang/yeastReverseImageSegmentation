import imageio
import imageio.v2 as iio2  #imageio‑v3 friendly import
import imageio.v3 as iio3

from sklearn.decomposition import PCA
import numpy as np, seaborn as sns
from cv2.detail import strip
from numpy import ndarray
from sklearn.cluster import MiniBatchKMeans
from skimage.color import lab2rgb,  deltaE_ciede2000

from skimage.draw import ellipse

from typing import List

import os
import cv2
import time
import math

import tifffile as tiff
import matplotlib.pyplot as plt
from skimage.color import label2rgb  #nice categorical colouring
from skimage.color import rgb2gray
from pathlib import Path

print("Done Importing")

notebook_directory = os.getcwd()

print(f"Notebook directory: {notebook_directory}")


_DOUBLE_EPS  = np.finfo(np.float64).eps     # ≈ 2.22e‑16
_DOUBLE_TINY = np.finfo(np.float64).tiny    # ≈ 2.23e‑308


import os
import json
import time
from typing import Tuple, Dict, Any
from    skimage.color   import deltaE_ciede2000
import cv2
import imageio
import numpy as np

"""ellipseExamplesIo.py

Routines for saving, loading, visualising and benchmarking the label
images generated by *EllipseGeneralForm*.  These helpers depend on the core
functions living in the companion module (see `ellipse_params_to_general_form`,
`create_ellipse_mask_vectorized`, `create_ellipse_mask_mathematical`, and
`generate_uint8_labels`).
"""
#If you saved the core under a module name, replace
#the relative import accordingly.

# The following imports assume this helper lives in the same package / notebook
# as the previously‑defined numerical core


from  ellipseMath import (
    ellipse_params_to_general_form,
    create_ellipse_mask_vectorized_perturbed,
    generate_uint8_labels,
    generate_uint8_labels_cv2,
)

__all__ = [
    "save_uint8_labels",
    "load_uint8_labels",
    "visualize_uint8_labels",
    #"compare_mask_generation_methods", removed
    "complete_pipeline",
    "inspect_uint8_output",
    "generate_uint8_labels_cv2",
]


#                                                                           -
# I/O HELPERS
#                                                                           -

def save_uint8_labels(uint8_labels: np.ndarray,dimensions,offset, metadata, base_filename: str) -> Dict[str, Any]:
    """Save a uint8 label map in four companion formats.

    1. Raw binary (`*.uint8`)
    2. NumPy array (`*.npy`)
    3. 8‑bit PNG (`*_labels.png`)
    4. JSON metadata (`*_metadata.json`)

    Parameters

    uint8_labels : np.ndarray, dtype ``np.uint8``
        The label image to write.
    base_filename : str
        Path *without* extension; the four outputs will append their own
        extensions as shown above.
    """
    if uint8_labels.dtype != np.uint8:
        raise TypeError("uint8_labels must be of dtype uint8")

    # 1 — raw canvased  binary
    uint8_labels.tofile(f"{base_filename}.uint8")
    print(f"Saved raw binary: {base_filename}.uint8")

    # 2 — NumPy .npy
    np.save(f"{base_filename}.npy", uint8_labels)
    print(f"Saved NumPy array: {base_filename}.npy")

    # 3 — PNG (palettised if desired)
    imageio.imwrite(f"{base_filename}_labels.png", uint8_labels)
    print(f"Saved PNG: {base_filename}_labels.png")

    # 4 — simple metadata
    metadata: Dict[str, Any] = {
        "width": dimensions[0],
        "height": dimensions[1],
        "dtype": "uint8",
        "unique_labels": np.unique(uint8_labels).tolist(),
        "max_label": int(uint8_labels.max()),
        "offset": offset,
        "fluorescence": metadata["fluorescence"],
    }
    with open(f"{base_filename}_metadata.json", "w", encoding="utf-8") as f:
        json.dump(metadata, f, indent=2)
    print(f"Saved metadata: {base_filename}_metadata.json")

    return metadata


def load_uint8_labels(filename: str, width: int, height: int) -> np.ndarray:
    """Load a raw ``*.uint8`` file previously written by
    :func:`save_uint8_labels`.
    """
    flat_array = np.fromfile(filename, dtype=np.uint8)
    return flat_array.reshape((height, width))

def n_spaced_lab(n:int=9):
    """
    Generate perceptually spaced cluster centers in array of shape (n_clusters,3) with Lab coords
    """
    rng = np.random.default_rng(n)
    lab = rng.uniform([0, -40, -40],  # L* >= 0
                      [100, 40, 40],  # cut a*,b* to a sensible gamut‑like cube
                      size=(5000, 3))
    k = MiniBatchKMeans(n_clusters=n, batch_size=1536).fit(lab)
    return k.cluster_centers_.astype(np.float32)

def order_for_gradient(lab):
    """Return an index array giving a ΔE‑smoothed order."""
    # PCA
    n = lab.shape[0]
    if n < 2:   #trivial
        return np.arange(n, dtype=int)

    pc1 = PCA(n_components=1).fit_transform(lab).ravel()
    order = np.argsort(pc1)
    # ΔE check
    lab_sorted = lab[order]
    if (deltaE_ciede2000(lab_sorted[:-1], lab_sorted[1:]).max() > 25):
        order = np.argsort(lab[:,0])   # fallback: by lightness
    return order
def gradient_palette(n_colors, background_dark=True):
    lab = n_spaced_lab(n_colors)
    idx = order_for_gradient(lab)
    if background_dark:
        idx = idx[np.argsort(lab[idx,0])]      # ascending L*: darkest first
    ordered_lab = lab[idx]
    rgb_u8 = np.clip(lab2rgb(ordered_lab[None])[0] * 255, 0, 255).astype(np.uint8)
    return rgb_u8                              #

def colormap_for_cells(unique_cell_ids):#Default 0-(9+1)
    n = unique_cell_ids.max()         #assumes labels 1…n
    print(unique_cell_ids)
    palette = gradient_palette(n+1)   # returns n+1 rows
    print(palette)
    return palette[unique_cell_ids]

def palette_to_strip(rgb_float, h,thickness,
                   out_file="palette.png"):
    """
    rgb_float   : (n,3) array in 0-255 *float*
    h           : image height in pixels
    thickness   : width in pixels of the strip
    """
    print("HORSSSEEEEEE")
    rgb_u8 = np.clip(np.round(rgb_float), 0, 255).astype(np.uint8)

    #generate interpolation anchors
    anchors = np.linspace(0, h - 1, len(rgb_float), dtype=np.float32)
    base = np.arange(h, dtype=np.float32)

    #build a 1-pixel-wide column, then widen
    col = np.empty((h, 1, 3), dtype=np.uint8)
    for ch in range(3):  # R, G, B channels
        col[:, 0, ch] = np.interp(base, anchors, rgb_u8[:, ch]).round().astype(
            np.uint8)
    #tile to desired thickness - i had it upside down so flip it vertically - then save
    img = np.flipud(np.tile(col, (1, thickness, 1)))
    iio3.imwrite(out_file, img)
    return img
def colormap_for_cells(unique_labels):
    n = unique_labels.max()+1        # assumes labels 1…n, 0=background
    palette = gradient_palette(n)   # returns n+1 rows
    return palette[unique_labels]   # broadcast lookup

_DEFAULT_CELL_IDS   =   np.array(range(0,9+1),  np.uint8)
_DEFAULT_COLORMAP    =   colormap_for_cells(_DEFAULT_CELL_IDS)
_FALSE_YELLOW   =   tuple(int("#CFCF00".lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
def visualize_uint8_labels(uint8_labels: np.ndarray,    metadata:   Dict,colormap:  Dict) -> np.ndarray:
    """Turn a label map into an RGB image using a lookup table.
    Extra labels beyond the length of the palette receive random colours.
    """
    if colormap is None:
        #ASSUME LABELS ARE FROM 1 to N
        label_idx       =   np.array(metadata["unique_labels"], dtype=int)
        color_idx       = np.concatenate(([0], label_idx))    #build a full-length colormap of shape (max_label+1, 3)
        base_colormap   = colormap_for_cells(color_idx)

        max_label       = int(uint8_labels.max())
        needed = max_label + 1 - base_colormap.shape[0]

        if needed > 0:
            # add random extras so that base_cmap has enough rows
            extra = np.random.randint(50, 256, (needed, 3), dtype=np.uint8)
            colormap = np.vstack([base_colormap, extra])
        else:
            colormap = base_colormap
    # now safe to index
    return colormap[uint8_labels]


#                                                                           -
# BENCHMARK / DEMO UTILITIES
#                                                                           -

#unnecessary after using theese to test ellipses
"""
def _mask_pair(w: int, h: int, center_x: float, center_y: float, a: float, b: float, angle: float):
    coeffs = ellipse_params_to_general_form(center_x, center_y, a, b, angle)
    mask_math = create_ellipse_mask_mathematical(w, h, coeffs)
    mask_vec  = create_ellipse_mask_vectorized(w, h, coeffs)
    return mask_math, mask_vec


def compare_mask_generation_methods() -> None:
    Benchmark pixel‑loop vs. vectorised mask generators for a single ellipse.

    w, h = 128, 128
    center_x, center_y = 64, 64
    a, b = 20, 15
    angle = 30

    print("=== Comparing Ellipse Mask Generation Methods ===")
    print(f"Image size: {w}x{h}")
    print(f"Ellipse: center=({center_x},{center_y}), axes=({a},{b}), rotation={angle}°")

    start = time.time()
    mask_math, mask_vec = _mask_pair(w, h, center_x, center_y, a, b, angle)
    identical = np.array_equal(mask_math, mask_vec)
    print(f"\nMasks identical: {identical}")
    if not identical:
        diff = int((mask_math ^ mask_vec).sum())
        print(f"  Differences: {diff} pixels")

"""

def complete_pipeline(cells_data:    Dict) -> Tuple[np.ndarray, np.ndarray]:
    """Run the full generate -> save -> visualise pipeline on a toy dataset."""
    w, h = 128, 200
    if  cells_data is None:
        cells_data = {
            "indices":       list(range(1, 10)),
            "fluorescence":  [100, 120, 80, 150, 90, 110, 130, 140, 95],
            "size":          [15, 18, 14, 20, 16, 17, 19, 18, 15],
            "shape":         [(8, 19), (10, 13), (7, 6), (11, 7), (13, 8),
                               (9, 9), (11, 8), (45, 9), (18, 7)],
            "location":      [(30, 25), (30, 50), (40, 80), (60, 30),
                               (85, 70), (110, 25), (110, 85), (110, 110), (80, 110)],
            "rotation":      [0, 15, -20, 30, 0, 45, -10, 0, 25],
        }

    print("=== STEP 1: Generate canvas of uint8 labels ===")
    uint8_labels,   dimensions,    offset = generate_uint8_labels(w, h, cells_data)

    print("\n=== STEP 2: Save uint8 labels ===")
    metadata    =   save_uint8_labels(uint8_labels, dimensions, offset,cells_data, "dump0\canvased_yeast_segmentation")
    cropped_uint8_labels  =   canvas_slicer(uint8_labels, dimensions, offset)

    cropped_metadata    =   save_uint8_labels(cropped_uint8_labels, dimensions, offset, "dump0\cropped_yeast_segmentation")

    print("\n=== STEP 3: Define and order colorMap to cells ===")
    thickness   =   10
    cells = np.array(range(0, len(cells_data["indices"]) + 1), dtype=np.uint8)
    colormap    =   colormap_for_cells(cells)
    strip = palette_to_strip(colormap, 200, thickness)

    print("\n=== STEP 4: Visualise ===")
    rgb_vis = visualize_uint8_labels(cropped_uint8_labels,metadata,colormap)
    imageio.imwrite("yeast_segmentation_visual.png", rgb_vis)
    print("Saved visualisation: yeast_segmentation_visual.png")

    return cropped_uint8_labels, rgb_vis

def canvas_slicer(canvas:   np.ndarray,dimensions:tuple,offset) -> np.ndarray:
    row_off, col_off = offset[0], offset[1]
    raster_h, raster_w = dimensions[0], dimensions[1]
    cropped =   canvas[row_off: row_off + raster_h,
                  col_off: col_off + raster_w]
    return cropped

def inspect_uint8_output(uint8_labels: np.ndarray) -> None:
    """Pretty‑print basic stats and a small patch of a label image."""
    print("=== Uint8 Label Array Inspection ===")
    print(f"Shape        : {uint8_labels.shape}")
    print(f"Data type    : {uint8_labels.dtype}")
    print(f"Memory       : {uint8_labels.nbytes} bytes")
    print(f"Min | Max    : {uint8_labels.min()} | {uint8_labels.max()}")

    unique, counts = np.unique(uint8_labels, return_counts=True)
    print("\nPixel counts per label:")
    for label, count in zip(unique, counts):
        tag = "Background" if label == 0 else f"Cell {label}"
        print(f"  {tag:11}: {count} px")

    print("\nSample (top‑left 10×10) of raw values:")
    print(uint8_labels[:10, :10])


#                                                                           -
# OpenCV‑BASED FAST FILL HELPER
#                                                                           -
from noise  import  pnoise2



#!/usr/bin/env python3
"""
ellipse_pipeline_demo.py  •  Stage-B unit test
------------------------------------------------
• Builds a 2048² mother-with-bud label mask
• Adds a smaller rotated inner ellipse (dark spot)
• Maps per-cell fluorescence with radial gamma profile
• Blurs with Gaussian PSF σ=1.2 px  ➜  mixed Poisson–Gaussian noise
• Saves RGB label visualisation + uint16 fluorescence TIFF
"""

import os, math, time, numpy as np, matplotlib.pyplot as plt
from numpy.random import default_rng
from scipy import ndimage                                     # PSF blur  :contentReference[oaicite:9]{index=9}
from perlin_numpy import generate_perlin_noise_2d             # Perlin  :contentReference[oaicite:10]{index=10}

import ellipseMath, ellipseExamplesIo
from ellipseMath import (add_bud_random_rotation,
                         ellipse_mask_rot_jitter, _fit_periods,
                         ellipse_params_to_general_form,
                         create_ellipse_mask_vectorized_perturbed2,
                         center_offset)
#from ellipseExamplesIo import visualize_uint8_labels

rng = default_rng(42)

# --------------------------------------------------------------------
# parameters
H = W = 2048
SIGMA_PSF = 1.2           # px  (optics blur)  :contentReference[oaicite:11]{index=11}
BITDEPTH  = 16
GAMMA     = 0.7
BUD_PROB  = 1.0           # always add a bud for demo
NUCL_RATIO = 0.3          # inner dark ellipse as % of mother radius

# --------------------------------------------------------------------
def generate_uint8_labels_with_buds(w, h, cells_data, *, rng, bud_prob=0.4):
    canvas_shape = (H, W)
    labels = np.zeros(canvas_shape, dtype=np.uint8)
    row_off, col_off = center_offset(canvas_shape, (h, w))

    for cid, (a, b), (cx, cy), angle in zip(cells_data["indices"],
                                            cells_data["shape"],
                                            cells_data["location"],
                                            cells_data["rotation"]):
        coeffs = ellipse_params_to_general_form(cx, cy, a, b, angle)
        parent = create_ellipse_mask_vectorized_perturbed2(
            w, h, coeffs, 0.07, 64, (row_off, col_off))
        parent = _maybe_add_bud(parent, (cy, cx), (a, b),
                                rng=rng, prob=bud_prob)
        labels[parent] = cid
    return labels

def _maybe_add_bud(parent_mask, parent_center, parent_axes, *, rng, prob):
    if rng.random() > prob:
        return parent_mask
    b_cen, b_axes, b_rot = add_bud_random_rotation(parent_center,
                                                   parent_axes, rng=rng)
    bud = ellipse_mask_rot_jitter(*parent_mask.shape, b_cen, b_axes, b_rot,
                                  jitter=0.05, noise_scale=96,
                                  seed=rng.integers(1<<31))
    return parent_mask | (bud & ~parent_mask)

# --------------------------------------------------------------------
def render_fluor_image(label_map, *, sigma_px, bitdepth, gamma, rng):
    img = np.zeros_like(label_map, dtype=np.float32)
    for cid in np.unique(label_map):
        if cid == 0:
            continue
        mask = label_map == cid
        yy, xx = np.where(mask)
        cy, cx = np.median(yy), np.median(xx)
        r_max  = np.sqrt(((yy - cy)**2 + (xx - cx)**2).max())

        rr = np.sqrt((yy - cy)**2 + (xx - cx)**2)
        F0 = rng.uniform(0.6, 1.0)
        img[yy, xx] = F0 * (1. - (rr / (r_max+1e-6))**gamma)

        # inner dark ellipse (nucleolus)
        nucl_axes = (NUCL_RATIO * r_max, NUCL_RATIO * r_max)
        nucl_rot  = rng.uniform(0, 180.)
        nucl = ellipse_mask_rot_jitter(*label_map.shape,
                                       (cy, cx), nucl_axes, nucl_rot,
                                       jitter=0.03, noise_scale=64,
                                       repeat=True)#, rng=rng)
        img[nucl] *= rng.uniform(0.4, 0.6)

    # PSF blur
    img = ndimage.gaussian_filter(img, sigma_px)              # :contentReference[oaicite:12]{index=12}

    # Mixed Poisson–Gaussian noise (FMD style) :contentReference[oaicite:13]{index=13}:contentReference[oaicite:14]{index=14}
    counts = img * 6000.0
    counts = rng.poisson(counts)
    counts = counts + rng.normal(0, 60, counts.shape)  # read noise
    counts = np.clip(counts, 0, 2**bitdepth - 1)
    return counts.astype(np.uint16)

# --------------------------------------------------------------------
if __name__ == "__main__":
    t0 = time.time()
    toy = {
        "indices":   [1, 2],
        "shape":     [(300, 240), (280, 200)],
        "location":  [(700, 800), (1300, 1200)],
        "rotation":  [10, -20],
    }
    mask = generate_uint8_labels_with_buds(W, H, toy, rng=rng, bud_prob=BUD_PROB)
    vis_rgb = visualize_uint8_labels(mask,
                {"unique_labels":[0,1,2],"width":W,"height":H}, None)
    I0 = render_fluor_image(mask, sigma_px=SIGMA_PSF,
                            bitdepth=BITDEPTH, gamma=GAMMA, rng=rng)

    # --- output & quick stats ---
    imageio.imwrite("demo_mask_rgb.png", vis_rgb)
    imageio.imwrite("demo_fluor.tiff",   I0)
    print(f"demo_fluor mean={I0.mean():.1f}  max={I0.max()}  "
          f"elapsed {time.time()-t0:.2f}s")

    # display side-by-side for notebook use
    fig, ax = plt.subplots(1,2, figsize=(10,5))
    ax[0].imshow(vis_rgb);   ax[0].set_title("Label RGB");   ax[0].axis("off")
    ax[1].imshow(I0, cmap='viridis'); ax[1].set_title("Fluorescence I₀"); ax[1].axis("off")
    plt.tight_layout(); plt.show()


def create_ellipse_mask_vectorized_perturbed(w: int, h: int, coeffs: dict,
                                             jitter: np.float32 = 0.07,
                                             noise_scale: int = 64,
                                             offset:    tuple[int,int]=(0,0),
                                             seed: int | None = None):

    """
    As `create_ellipse_mask_vectorized`, but boundary is perturbed by Perlin
    noise.  `jitter` ≈ relative amplitude; `noise_scale` controls feature size.
    """
    #2048x2048
    #r(θ) = ab / sqrt((b cosθ)^2 + (a sinθ)^2)
#    rng = np.random.default_rng(seed)#       Recover    pixel    semi‑axes
    semi_a,  semi_b = coeffs["semi_a"], coeffs["semi_b"]
    xSqr_coeff  =   coeffs["A"]
    ySqr_coeff = coeffs["B"]


    offset_row, offset_col = offset[0], offset[1]
    center_x, center_y = coeffs["k"]+offset_col, \
        offset_row+coeffs["l"]
    #h is height and w is width so coordinate grids


    eps =   np.finfo(np.float32).eps
    scale   =   max(semi_a,semi_b)
    a32_hat,    b32_hat =   semi_a/scale,    semi_b/scale
    y_grid, x_grid = np.ogrid[:2048, :2048] #[:h,:w]
    #

    yy, xx = np.indices((2048, 2048))

    dx, dy = xx - center_x, yy - center_y
    theta = np.arctan2(dy, dx,  dtype=np.float32)

    # Ideal ellipse radius for every pixel direction
    #r_ideal = (a * b) / np.sqrt((b * np.cos(theta)) ** 2 +
    #                            (a * np.sin(theta)) ** 2)
    #       =scale^2*a_hat*b_hat/
#(cont.)  np.sqrt(scale^2*[(b_hat*cos)^2+(a_hat*sin)^2])
    #       =scale*a_hat*b_hat/
    # (cont.)  np.sqrt([(b_hat*cos)^2+(a_hat*sin)^2])

    #scale in top and bottom gets taken out
    # so all we deal with are the hats  and one scale
    # leads to more bits to work with
    denom = np.hypot(b32_hat*np.cos(theta), a32_hat*np.sin(theta))
    r_ideal =   (a32_hat * b32_hat)*scale/denom
    # 2‑D Perlin noise field ∈ [‑1,1]

    print("MAKE NOISE")
    noise = np.clip(np.vectorize(lambda y0, x0: pnoise2(x0/noise_scale,
                                                     y0/noise_scale,
                                                     repeatx=w, repeaty=h,
                                                     base=seed or 0),
                               otypes=[np.float32])(yy, xx),
                  -1.0, 1.0)
    delta = jitter * noise
    r_px = np.hypot(dx, dy)
    print(f"PIXELS BACK - scale {scale}")
    print(np.sum(r_px <= scale))
    #return r_px <= scale
    return r_px <= r_ideal * (1.0 + delta   +   eps)


if __name__ == "__main__":
    print("Running quick smoke tests for ellipse I/O + visualisation module…\n")

    # 1. Benchmark mathematical vs. vectorised
#    compare_mask_generation_methods()

    # 2. Full pipeline on toy dataset
    labels, rgb = complete_pipeline(None)
    inspect_uint8_output(labels)
    print("Demo RGB image saved as demo_labels_vis.png\n")
    #no more need for cv2
    """
    # 3. CV2 generator sanity check
    cv2_cells = {
        "indices": [1],
        "fluorescence": [0],
        "shape": [(25, 18)],
        "location": [(64, 64)],
        "rotation": [45],
    }
    cv2_labels,dimensions,offset = generate_uint8_labels_cv2(128, 128, cv2_cells)
    print("OpenCV generator produced label with unique values:", np.unique(cv2_labels))
    inspect_uint8_output(cv2_labels)
    print("All tests completed successfully.")
    """



    root = Path.cwd()  # same as os.getcwd()
    data_dir = root / "gold-standard-PhC-plus-2"  # cross‑platform join
    assert data_dir.is_dir(), f"{data_dir} does not exist"

    all_tifs = sorted(
        p for p in data_dir.glob("*.tif")  # pathlib.glob ≈ glob.glob
        if p.is_file()
    )
    print(f"Found {len(all_tifs)} TIFFs")

    # Ensure we have an even number of files
    if len(all_tifs) % 2:
        raise ValueError("Uneven number of TIFFs – check your directory!")

    pairs = [
        (all_tifs[i], all_tifs[i + 1])  # (mask, image)
        for i in range(0, len(all_tifs), 2)
    ]

    for mask_path, img_path in pairs:
        print("MASK :", mask_path.name)
        print("IMAGE:", img_path.name)
        # ─── load & process here ───


    def preview(mask_p, img_p, frame=0, alpha=0.4):
        # -------- load one frame --------
        mask = tiff.imread(mask_p)[frame]  # (H, W)  integer labels
        img = tiff.imread(img_p)[frame]  # (H, W) or (H, W, 3)

        # -------- prepare background --------
        if img.ndim == 3 and img.shape[-1] == 3:  #rgb -> luminance
            gray_img = rgb2gray(img)
        else:  #already grayscale
            gray_img = img.astype(np.float32)
            gray_img /= gray_img.max() or 1  # normalise 0‑1
        overlay = label2rgb(
            mask,  # keep IDs intact
            image=gray_img,
            bg_label=0,
            alpha=alpha  # transparencenter_y
        )

        overlay = np.clip(overlay, 0, 1)

        plt.figure(figsize=(6, 6))
        plt.imshow(overlay)
        plt.axis("off")
        plt.title(f"{mask_p.name} | frame {frame}")
        plt.show()



    # view the first pair
    preview(*pairs[0])
