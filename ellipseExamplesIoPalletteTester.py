import imageio
import imageio.v2 as iio2  #imageio‑v3 friendly import
import imageio.v3 as iio3




from sklearn.cluster import MiniBatchKMeans
from skimage.color import lab2rgb
import numpy as np
import matplotlib.pyplot as plt


from sklearn.decomposition import PCA
import numpy as np, seaborn as sns
from cv2.detail import strip
from numpy import ndarray
from sklearn.cluster import MiniBatchKMeans
from skimage.color import lab2rgb,  deltaE_ciede2000

from skimage.draw import ellipse

from typing import List

import os
import cv2
import time
import math

import tifffile as tiff
import matplotlib.pyplot as plt
from skimage.color import label2rgb  #nice categorical colouring
from skimage.color import rgb2gray
from pathlib import Path

print("Done Importing")

notebook_directory = os.getcwd()

print(f"Notebook directory: {notebook_directory}")


_DOUBLE_EPS  = np.finfo(np.float64).eps     # ≈ 2.22e‑16
_DOUBLE_TINY = np.finfo(np.float64).tiny    # ≈ 2.23e‑308


import os
import json
import time
from typing import Tuple, Dict, Sequence,   Any
from    skimage.color   import deltaE_ciede2000
import cv2
import imageio
import numpy as np

"""ellipseExamplesIo.py

Routines for saving, loading, visualising and benchmarking the label
images generated by *EllipseGeneralForm*.  These helpers depend on the core
functions living in the companion module (see `ellipse_params_to_general_form`,
`create_ellipse_mask_vectorized`, `create_ellipse_mask_mathematical`, and
`generate_uint8_labels`).
"""
#If you saved the core under a module name, replace
#the relative import accordingly.

# The following imports assume this helper lives in the same package / notebook
# as the previously‑defined numerical core


from  ellipseMath import (
    ellipse_params_to_general_form,
    create_ellipse_mask_vectorized_perturbed,
    generate_uint8_labels,
    generate_uint8_labels_cv2,
edge_mask_np,
)

__all__ = [
    "save_uint8_labels",
    "load_uint8_labels",
    "visualize_uint8_labels",
    #"compare_mask_generation_methods", removed
    "complete_pipeline",
    "inspect_uint8_output",
    "generate_uint8_labels_cv2",
]


#                                                                           -
# I/O HELPERS
#                                                                           -

def save_uint8_labels(uint8_labels: np.ndarray,dimensions,offset,
                      metadata: Dict[str, Any] | Sequence[Dict[str, Any]]
                      , base_filename: str) -> Dict[str, Any]:
    """Save a uint8 label map in four companion formats.

    1. Raw binary (`*.uint8`)
    2. NumPy array (`*.npy`)
    3. 8‑bit PNG (`*_labels.png`)
    4. JSON metadata (`*_metadata.json`)

    Parameters

    uint8_labels : np.ndarray, dtype ``np.uint8``
        The label image to write.
    base_filename : str
        Path *without* extension; the four outputs will append their own
        extensions as shown above.
    """
    if uint8_labels.dtype != np.uint8:
        raise TypeError("uint8_labels must be of dtype uint8")
    base = Path(base_filename)

    # 1 — raw canvased  binary
    uint8_labels.tofile(base.with_suffix(".uint8"))
    print(f"Saved raw binary: {base_filename}.uint8")

    # 2 — NumPy .npy
    np.save(base.with_suffix(".npy"), uint8_labels)
    print(f"Saved NumPy array: {base_filename}.npy")

    # 3 — PNG (palettised if desired)
    imageio.imwrite(base.with_name(base.stem + "_labels.png"), uint8_labels)
    print(f"Saved PNG: {base_filename}_labels.png")

    # 4 — simple metadata
    metadata_output: Dict[str, Any] = {
        "width": dimensions[0],
        "height": dimensions[1],
        "dtype": "uint8",
        "unique_labels": np.unique(uint8_labels).tolist(),
        "max_label": int(uint8_labels.max()),
        "offset": offset,
        "fluorescence": metadata["fluorescence"],
    }

    #optionally surface aggregate fluorescence for convenience
    if isinstance(metadata, dict):                       # single-dict case :contentReference[oaicite:3]{index=3}
        metadata_output.update(metadata)                        # copy all keys
        if "fluorescence" in metadata:
            metadata_output["fluorescence"] = metadata["fluorescence"]
    else:                                                # sequence of dicts
        metadata_output["cells"] = list(metadata)               # keep full list
        # flatten fluorescence values if present
        #proceeds with fluorescence extraction iff the list is not empty and first dict holds fluor_data
        if metadata and "fluorescence" in metadata[0]:
            metadata_output["fluorescence"] = [
                cell["fluorescence"] for cell in metadata
            ]
    with open(base.with_name(base.stem + "_metadata.json"), "w", encoding="utf-8") as f:
        json.dump(metadata_output, f, indent=2)
    print(f"Saved metadata: {base_filename}_metadata.json")

    return metadata_output


def load_uint8_labels(filename: str, width: int, height: int) -> np.ndarray:
    """Load a raw ``*.uint8`` file previously written by
    :func:`save_uint8_labels`.
    """
    flat_array = np.fromfile(filename, dtype=np.uint8)
    return flat_array.reshape((height, width))

#color vis

def gradient_palette(n_colors: int, *, seed: int | None = None) -> np.ndarray:
    """
    Return an (n_colors,3) uint8 array spanning a perceptually uniform
    gradient in CIELab → RGB.  Darker tones come first so label 1 appears
    darker than label n.
    """
    rng = np.random.default_rng(seed)
    # sample a wide Lab cube then K-means cluster
    lab = rng.uniform([20, -40, -40], [90, 40, 40], size=(4096, 3)).astype(np.float32)
    km  = MiniBatchKMeans(n_clusters=n_colors, batch_size=1024,
                          random_state=seed).fit(lab)
    centres = km.cluster_centers_
    order   = np.argsort(centres[:, 0])          # sort by lightness L*
    rgb     = lab2rgb(centres[order][None])[0]   # -> 0-1 float
    return np.clip(rgb * 255, 0, 255).astype(np.uint8)

def make_colormap(unique_cell_ids: np.ndarray,
                  *, background: tuple[int, int, int] = (0, 0, 0)
                  ) -> np.ndarray:
    """
    Build a palette where *row i* is the colour for *cell_id i*.
    `unique_cell_ids` must include **all** positive IDs present.
    Row 0 is the background colour.
    """
    n = unique_cell_ids.max() if unique_cell_ids.size else 0
    palette = np.zeros((n + 1, 3), dtype=np.uint8)
    palette[0] = background
    if n:
        palette[1:] = gradient_palette(n)
    return palette

def visualize_uint8_labels(
        coll_masks: np.ndarray,
        metadata: dict | list | None = None,
        palette: np.ndarray | None = None
) -> tuple[np.ndarray, np.ndarray]:
    """
    Convert a stack **(N,H,W)** of binary masks to an RGB visualisation
    **and** return the palette used.

    Returns
    -------
    rgb_vis : (H,W,3) uint8  – label image in colour
    palette : (max_id+1,3) uint8 – row i = colour for cell_id i
    """
    if coll_masks.ndim != 3:
        raise ValueError("coll_masks must have shape (N,H,W)")
    masks = coll_masks.astype(bool, copy=False)
    N, H, W = masks.shape

    # numeric label map
    label_img = (masks * (np.arange(1, N + 1,
                                    dtype=np.uint16)[:, None, None])).max(axis=0)

    # build / extend palette
    if palette is None:
        if isinstance(metadata, dict):
            cell_ids = np.asarray(metadata.get("unique_labels",
                                               np.arange(1, N + 1)), dtype=int)
        else:
            cell_ids = np.arange(1, N + 1, dtype=int)
        palette = make_colormap(cell_ids)
    if palette.shape[0] <= label_img.max():
        extra = gradient_palette(label_img.max() - palette.shape[0] + 1)
        palette = np.vstack([palette, extra])

    rgb_vis = palette[label_img]          # LUT
    return rgb_vis, palette

def palette_to_strip(palette: np.ndarray, h: int, thickness: int = 20
                     ) -> np.ndarray:
    """
    Turn *palette* (n,3) → vertical strip image (h, thickness, 3) for legends.
    """
    taps   = palette.shape[0]
    knots  = np.linspace(0, h - 1, taps).astype(np.float32)
    base_y = np.arange(h, dtype=np.float32)
    col    = np.empty((h, 1, 3), dtype=np.uint8)
    for ch in range(3):
        col[:, 0, ch] = np.interp(base_y, knots, palette[:, ch]).round()
    return np.flipud(np.tile(col, (1, thickness, 1)))   # darkest at top

def show_labels_and_palette(label_rgb: np.ndarray,
                            palette: np.ndarray,
                            *,
                            cell_ids: list[int] | None = None,
                            thickness: int = 32,
                            figsize=(8, 4)):
    """
    Quick preview: label RGB on the left, palette bar + IDs on the right.
    """
    if cell_ids is None:
        cell_ids = list(range(1, palette.shape[0]))
    strip = palette_to_strip(palette, label_rgb.shape[0], thickness)

    fig, (ax0, ax1) = plt.subplots(
        1, 2, gridspec_kw={'width_ratios': [4, 1]}, figsize=figsize
    )
    # label image
    ax0.imshow(label_rgb)
    ax0.set_axis_off()
    ax0.set_title("Label RGB")

    # palette strip
    ax1.imshow(strip)
    ax1.set_axis_off()
    for i, cid in enumerate(cell_ids):
        y = int(label_rgb.shape[0] * (i + 0.5) / len(cell_ids))
        ax1.text(thickness + 4, y, str(cid),
                 va='center', ha='left', fontsize=8, color='white')
    ax1.set_title("Palette")
    plt.tight_layout()
    plt.show()
# ─────────────────────────────────────────────────────────────────────────────



#unnecessary after using theese to test ellipses
"""
def _mask_pair(w: int, h: int, center_x: float, center_y: float, a: float, b: float, angle: float):
    coeffs = ellipse_params_to_general_form(center_x, center_y, a, b, angle)
    mask_math = create_ellipse_mask_mathematical(w, h, coeffs)
    mask_vec  = create_ellipse_mask_vectorized(w, h, coeffs)
    return mask_math, mask_vec


def compare_mask_generation_methods() -> None:
    Benchmark pixel‑loop vs. vectorised mask generators for a single ellipse.

    w, h = 128, 128
    center_x, center_y = 64, 64
    a, b = 20, 15
    angle = 30

    print("=== Comparing Ellipse Mask Generation Methods ===")
    print(f"Image size: {w}x{h}")
    print(f"Ellipse: center=({center_x},{center_y}), axes=({a},{b}), rotation={angle}°")

    start = time.time()
    mask_math, mask_vec = _mask_pair(w, h, center_x, center_y, a, b, angle)
    identical = np.array_equal(mask_math, mask_vec)
    print(f"\nMasks identical: {identical}")
    if not identical:
        diff = int((mask_math ^ mask_vec).sum())
        print(f"  Differences: {diff} pixels")

"""

def complete_pipeline(cells_data:    Dict) -> Tuple[np.ndarray, np.ndarray]:
    """Run the full generate -> save -> visualise pipeline on a toy dataset."""
    w, h = 128, 200
    if  cells_data is None:
        cells_data = {
            "indices":       list(range(1, 10)),
            "fluorescence":  [100, 120, 80, 150, 90, 110, 130, 140, 95],
            "size":          [15, 18, 14, 20, 16, 17, 19, 18, 15],
            "shape":         [(8, 19), (10, 13), (7, 6), (11, 7), (13, 8),
                               (9, 9), (11, 8), (45, 9), (18, 7)],
            "location":      [(30, 25), (30, 50), (40, 80), (60, 30),
                               (85, 70), (95, 25), (100, 85), (110, 110), (80, 110)],
            "rotation":      [0, 15, -20, 30, 0, 45, -10, 0, 25],
        }

    print("=== STEP 1: Generate canvas of uint8 labels ===")
    uint8_labels,   dimensions,    offset = generate_uint8_labels(w, h, cells_data)

    base_file, _= os.path.split(os.path.abspath(__file__))
    print("\n=== STEP 2: Save uint8 labels ===")
    metadata    =   save_uint8_labels(uint8_labels, dimensions, offset,cells_data, f"{base_file}\dump0\canvased_yeast_segmentation")
    cropped_uint8_labels  =   canvas_slicer(uint8_labels, dimensions, offset)

    cropped_metadata    =   save_uint8_labels(cropped_uint8_labels, dimensions, offset,cells_data, f"{base_file}\dump0\cropped_yeast_segmentation")

    print("\n=== STEP 3: Define and order colorMap to cells ===")
    thickness   =   10
    cells = np.array(range(0, len(cells_data["indices"]) + 1), dtype=np.uint8)
    colormap    =   colormap_for_cells(cells)
    strip = palette_to_strip(colormap, 200, thickness)

    print("\n=== STEP 4: Visualise ===")
    rgb_vis = visualize_uint8_labels(cropped_uint8_labels,metadata,colormap)
    imageio.imwrite("yeast_segmentation_visual.png", rgb_vis)
    print("Saved visualisation: yeast_segmentation_visual.png")

    return cropped_uint8_labels, rgb_vis

def canvas_slicer(canvas:   np.ndarray,dimensions:tuple,offset) -> np.ndarray:
    row_off, col_off = offset[0], offset[1]
    raster_h, raster_w = dimensions[0], dimensions[1]
    cropped =   canvas[row_off: row_off + raster_h,
                  col_off: col_off + raster_w]
    return cropped

def inspect_uint8_output(uint8_labels: np.ndarray) -> None:
    """Pretty‑print basic stats and a small patch of a label image."""
    print("=== Uint8 Label Array Inspection ===")
    print(f"Shape        : {uint8_labels.shape}")
    print(f"Data type    : {uint8_labels.dtype}")
    print(f"Memory       : {uint8_labels.nbytes} bytes")
    print(f"Min | Max    : {uint8_labels.min()} | {uint8_labels.max()}")

    unique, counts = np.unique(uint8_labels, return_counts=True)
    print("\nPixel counts per label:")
    for label, count in zip(unique, counts):
        tag = "Background" if label == 0 else f"Cell {label}"
        print(f"  {tag:11}: {count} px")

    print("\nSample (top‑left 10×10) of raw values:")
    print(uint8_labels[:10, :10])


#                                                                           -
# OpenCV‑BASED FAST FILL HELPER
#                                                                           -






if __name__ == "__main__":
    print("Running quick smoke tests for ellipse I/O + visualisation module…\n")

    # 1. Benchmark mathematical vs. vectorised
#    compare_mask_generation_methods()

    # 2. Full pipeline on toy dataset
    labels, rgb = complete_pipeline(None)
    inspect_uint8_output(labels)
    print("Demo RGB image saved as demo_labels_vis.png\n")
    #no more need for cv2
    """
    # 3. CV2 generator sanity check
    cv2_cells = {
        "indices": [1],
        "fluorescence": [0],
        "shape": [(25, 18)],
        "location": [(64, 64)],
        "rotation": [45],
    }
    cv2_labels,dimensions,offset = generate_uint8_labels_cv2(128, 128, cv2_cells)
    print("OpenCV generator produced label with unique values:", np.unique(cv2_labels))
    inspect_uint8_output(cv2_labels)
    print("All tests completed successfully.")
    """



    root = Path.cwd()  # same as os.getcwd()
    data_dir = root / "gold-standard-PhC-plus-2"  # cross‑platform join
    assert data_dir.is_dir(), f"{data_dir} does not exist"

    all_tifs = sorted(
        p for p in data_dir.glob("*.tif")  # pathlib.glob ≈ glob.glob
        if p.is_file()
    )
    print(f"Found {len(all_tifs)} TIFFs")

    # Ensure we have an even number of files
    if len(all_tifs) % 2:
        raise ValueError("Uneven number of TIFFs - check your directory!")

    pairs = [
        (all_tifs[i], all_tifs[i + 1])  # (mask, image)
        for i in range(0, len(all_tifs), 2)
    ]

    for mask_path, img_path in pairs:
        print("MASK :", mask_path.name)
        print("IMAGE:", img_path.name)
        # ─── load & process here ───


    def preview(mask_p, img_p, frame=0, alpha=0.4):
        # -------- load one frame --------
        mask = tiff.imread(mask_p)[frame]  # (H, W)  integer labels
        img = tiff.imread(img_p)[frame]  # (H, W) or (H, W, 3)

        # -------- prepare background --------
        if img.ndim == 3 and img.shape[-1] == 3:  #rgb -> luminance
            gray_img = rgb2gray(img)
        else:  #already grayscale
            gray_img = img.astype(np.float32)
            gray_img /= gray_img.max() or 1  # normalise 0‑1
        overlay = label2rgb(
            mask,  # keep IDs intact
            image=gray_img,
            bg_label=0,
            alpha=alpha  # transparencenter_y
        )

        overlay = np.clip(overlay, 0, 1)

        plt.figure(figsize=(6, 6))
        plt.imshow(overlay)
        plt.axis("off")
        plt.title(f"{mask_p.name} | frame {frame}")
        plt.show()



    # view the first pair
    preview(*pairs[0])
