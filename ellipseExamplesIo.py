import imageio
import numpy as np
from skimage.draw import ellipse
import os
import cv2
import time
import math

import tifffile as tiff
import matplotlib.pyplot as plt
from skimage.color import label2rgb  #nice categorical colouring
from skimage.color import rgb2gray
from pathlib import Path

print("Done Importing")

notebook_directory = os.getcwd()

print(f"Notebook directory: {notebook_directory}")


_DOUBLE_EPS  = np.finfo(np.float64).eps     # ≈ 2.22e‑16
_DOUBLE_TINY = np.finfo(np.float64).tiny    # ≈ 2.23e‑308


import os
import json
import time
from typing import Tuple, Dict, Any

import cv2
import imageio
import numpy as np

"""ellipseExamplesIo.py

Routines for saving, loading, visualising and benchmarking the label
images generated by *EllipseGeneralForm*.  These helpers depend on the core
functions living in the companion module (see `ellipse_params_to_general_form`,
`create_ellipse_mask_vectorized`, `create_ellipse_mask_mathematical`, and
`generate_uint8_labels`).
"""
#If you saved the core under a module name, replace
#the relative import accordingly.

# The following imports assume this helper lives in the same package / notebook
# as the previously‑defined numerical core


from  ellipseMath import (
    ellipse_params_to_general_form,
    create_ellipse_mask_vectorized,
    create_ellipse_mask_mathematical,
    generate_uint8_labels,
)

__all__ = [
    "save_uint8_labels",
    "load_uint8_labels",
    "visualize_uint8_labels",
    "compare_mask_generation_methods",
    "example_complete_pipeline",
    "inspect_uint8_output",
    "generate_uint8_labels_cv2",
]


#                                                                           -
# I/O HELPERS
#                                                                           -

def save_uint8_labels(uint8_labels: np.ndarray, base_filename: str) -> None:
    """Save a uint8 label map in four companion formats.

    1. Raw binary (`*.uint8`)
    2. NumPy array (`*.npy`)
    3. 8‑bit PNG (`*_labels.png`)
    4. JSON metadata (`*_metadata.json`)

    Parameters

    uint8_labels : np.ndarray, dtype ``np.uint8``
        The label image to write.
    base_filename : str
        Path *without* extension; the four outputs will append their own
        extensions as shown above.
    """

    if uint8_labels.dtype != np.uint8:
        raise TypeError("uint8_labels must be of dtype uint8")

    # 1 — raw binary
    uint8_labels.tofile(f"{base_filename}.uint8")
    print(f"Saved raw binary: {base_filename}.uint8")

    # 2 — NumPy .npy
    np.save(f"{base_filename}.npy", uint8_labels)
    print(f"Saved NumPy array: {base_filename}.npy")

    # 3 — PNG (palettised if desired)
    imageio.imwrite(f"{base_filename}_labels.png", uint8_labels)
    print(f"Saved PNG: {base_filename}_labels.png")

    # 4 — simple metadata
    metadata: Dict[str, Any] = {
        "width": int(uint8_labels.shape[1]),
        "height": int(uint8_labels.shape[0]),
        "dtype": "uint8",
        "unique_labels": np.unique(uint8_labels).tolist(),
        "max_label": int(uint8_labels.max()),
    }
    with open(f"{base_filename}_metadata.json", "w", encoding="utf-8") as f:
        json.dump(metadata, f, indent=2)
    print(f"Saved metadata: {base_filename}_metadata.json")


def load_uint8_labels(filename: str, width: int, height: int) -> np.ndarray:
    """Load a raw ``*.uint8`` file previously written by
    :func:`save_uint8_labels`.
    """
    flat_array = np.fromfile(filename, dtype=np.uint8)
    return flat_array.reshape((height, width))


#                                                                           -
# VISUALISATION
#                                                                           -

_DEFAULT_COLORS = np.array([
    [70, 50, 160],   # background (0)
    [100, 200, 255], # 1
    [80, 180, 255],  # 2
    [120, 255, 255], # 3
    [100, 200, 100], # 4
    [150, 255, 150], # 5
    [255, 255, 100], # 6
    [255, 200, 100], # 7
    [255, 150, 150], # 8
    [200, 150, 255], # 9
], dtype=np.uint8)


def visualize_uint8_labels(uint8_labels: np.ndarray, colormap: np.ndarray | None = None) -> np.ndarray:
    """Turn a label map into an RGB image using a lookup table.
    Extra labels beyond the length of the palette receive random colours.
    """
    if colormap is None:
        colormap = _DEFAULT_COLORS.copy()

    max_label = int(uint8_labels.max())
    if max_label >= len(colormap):
        n_extra = max_label + 1 - len(colormap)
        extra = np.random.randint(50, 256, (n_extra, 3), dtype=np.uint8)
        colormap = np.vstack([colormap, extra])

    return colormap[uint8_labels]


#                                                                           -
# BENCHMARK / DEMO UTILITIES
#                                                                           -

def _mask_pair(w: int, h: int, cx: float, cy: float, a: float, b: float, angle: float):
    coeffs = ellipse_params_to_general_form(cx, cy, a, b, angle)
    mask_math = create_ellipse_mask_mathematical(w, h, coeffs)
    mask_vec  = create_ellipse_mask_vectorized(w, h, coeffs)
    return mask_math, mask_vec


def compare_mask_generation_methods() -> None:
    """Benchmark pixel‑loop vs. vectorised mask generators for a single ellipse."""

    w, h = 128, 128
    cx, cy = 64, 64
    a, b = 20, 15
    angle = 30

    print("=== Comparing Ellipse Mask Generation Methods ===")
    print(f"Image size: {w}x{h}")
    print(f"Ellipse: center=({cx},{cy}), axes=({a},{b}), rotation={angle}°")

    start = time.time()
    mask_math, mask_vec = _mask_pair(w, h, cx, cy, a, b, angle)
    time_math = (time.time() - start) * 0.5  # first half for math
    time_vec  = time_math                    # second half for vec (same run)

    pixels_math = int(mask_math.sum())
    pixels_vec  = int(mask_vec.sum())

    print("\nMathematical (pixel‑loop) method:")
    print(f"  Time: {time_math*1e3:.2f} ms | Pixels: {pixels_math}")

    print("\nVectorised method:")
    print(f"  Time: {time_vec*1e3:.2f} ms | Pixels: {pixels_vec}")
    print(f"  Speedup: {time_math/time_vec if time_vec else float('inf'):.1f}×")

    identical = np.array_equal(mask_math, mask_vec)
    print(f"\nMasks identical: {identical}")
    if not identical:
        diff = int((mask_math ^ mask_vec).sum())
        print(f"  Differences: {diff} pixels")


def example_complete_pipeline() -> Tuple[np.ndarray, np.ndarray]:
    """Run the full generate -> save -> visualise pipeline on a toy dataset."""
    w, h = 128, 128
    cells_data = {
        "indices":       list(range(1, 10)),
        "fluorescence":  [100, 120, 80, 150, 90, 110, 130, 140, 95],
        "size":          [15, 18, 14, 20, 16, 17, 19, 18, 15],
        "shape":         [(8, 7), (10, 9), (7, 7), (11, 10), (9, 8),
                           (9, 9), (10, 8), (9, 9), (8, 7)],
        "location":      [(30, 25), (30, 50), (40, 80), (60, 30),
                           (85, 70), (110, 25), (110, 85), (110, 110), (80, 110)],
        "rotation":      [0, 15, -20, 30, 0, 45, -10, 0, 25],
    }

    print("=== STEP 1: Generate uint8 labels ===")
    uint8_labels = generate_uint8_labels(w, h, cells_data)

    print("\n=== STEP 2: Save uint8 labels ===")
    save_uint8_labels(uint8_labels, "yeast_segmentation")

    print("\n=== STEP 3: Visualise ===")
    rgb_vis = visualize_uint8_labels(uint8_labels)
    imageio.imwrite("yeast_segmentation_visual.png", rgb_vis)
    print("Saved visualisation: yeast_segmentation_visual.png")

    return uint8_labels, rgb_vis


def inspect_uint8_output(uint8_labels: np.ndarray) -> None:
    """Pretty‑print basic stats and a small patch of a label image."""

    print("=== Uint8 Label Array Inspection ===")
    print(f"Shape        : {uint8_labels.shape}")
    print(f"Data type    : {uint8_labels.dtype}")
    print(f"Memory       : {uint8_labels.nbytes} bytes")
    print(f"Min | Max    : {uint8_labels.min()} | {uint8_labels.max()}")

    unique, counts = np.unique(uint8_labels, return_counts=True)
    print("\nPixel counts per label:")
    for label, count in zip(unique, counts):
        tag = "Background" if label == 0 else f"Cell {label}"
        print(f"  {tag:11}: {count} px")

    print("\nSample (top‑left 10×10) of raw values:")
    print(uint8_labels[:10, :10])


#                                                                           -
# OpenCV‑BASED FAST FILL HELPER
#                                                                           -


def generate_uint8_labels_cv2(w: int,
                              h: int,
                              cells_data: dict) -> np.ndarray:
    """
    Alternative generator for very large batches where
    Python‑level loops become the bottleneck.
    Note that OpenCV uses the *endpoint‑inclusive* angle
    convention (startAngle, endAngle), so we pass 0‑to‑360.


    Rasterise filled ellipses directly with OpenCV and write the cell ID
    into a uint‑8 mask.

    Parameters
    - w, h : int
        - Output width × height in pixels.
    - cells_data : dict
        - Must contain the keys ``'indices'``, ``'shape'``, ``'location'``,
        - and ``'rotation'`` (same schema as the coefficient‑based pipeline).

    Returns
    - uint8_labels : np.ndarray, shape ``(h, w)``, dtype ``uint8``
            - Background pixels are 0; each ellipse interior is the
            corresponding ID from ``cells_data['indices']``.
    """
    #allocate target image (background = 0)
    uint8_labels = np.zeros((h, w), dtype=np.uint8)

    indices,    shapes, locations,  rotations   = cells_data["indices"],  cells_data["shape"] ,   cells_data["location"], cells_data["rotation"]

    #draw each ellipse in‑place
    for cell_id, (a, b), (cx, cy), angle_rot_numbers in zip(
        indices, shapes, locations, rotations
    ):
        if cell_id > 255:
            raise ValueError(f"Cell ID {cell_id} exceeds uint8 range 0‑255")

        center = (int(round(cx)), int(round(cy)))   # integer pixel coords
        axes   = (int(round(a)),  int(round(b)))    # integer semi‑axes

        # thickness = –1 (cv2.FILLED) -> fill the ellipse interior
        cv2.ellipse(
            img       = uint8_labels,
            center    = center,
            axes      = axes,
            angle     = float(angle_rot_numbers),  # CCW degrees
            startAngle= 0,
            endAngle  = 360,
            color     = int(cell_id),  # write the ID value
            thickness = -1
        )

    return uint8_labels



if __name__ == "__main__":
    print("Running quick smoke tests for ellipse I/O + visualisation module…\n")

    # 1. Benchmark mathematical vs. vectorised
    compare_mask_generation_methods()

    # 2. Full pipeline on toy dataset
    labels, rgb = example_complete_pipeline()
    inspect_uint8_output(labels)
    print("Demo RGB image saved as demo_labels_vis.png\n")

    # 3. CV2 generator sanity check
    cv2_cells = {
        "indices": [1],
        "fluorescence": [0],
        "shape": [(25, 18)],
        "location": [(64, 64)],
        "rotation": [45],
    }
    cv2_labels = generate_uint8_labels_cv2(128, 128, cv2_cells)
    print("OpenCV generator produced label with unique values:", np.unique(cv2_labels))
    inspect_uint8_output(cv2_labels)
    print("All tests completed successfully.")



    root = Path.cwd()  # same as os.getcwd()
    data_dir = root / "gold-standard-PhC-plus-2"  # cross‑platform join
    assert data_dir.is_dir(), f"{data_dir} does not exist"

    all_tifs = sorted(
        p for p in data_dir.glob("*.tif")  # pathlib.glob ≈ glob.glob
        if p.is_file()
    )
    print(f"Found {len(all_tifs)} TIFFs")

    # Ensure we have an even number of files
    if len(all_tifs) % 2:
        raise ValueError("Uneven number of TIFFs – check your directory!")

    pairs = [
        (all_tifs[i], all_tifs[i + 1])  # (mask, image)
        for i in range(0, len(all_tifs), 2)
    ]

    for mask_path, img_path in pairs:
        print("MASK :", mask_path.name)
        print("IMAGE:", img_path.name)
        # ─── load & process here ───


    def preview(mask_p, img_p, frame=0, alpha=0.4):
        # -------- load one frame --------
        mask = tiff.imread(mask_p)[frame]  # (H, W)  integer labels
        img = tiff.imread(img_p)[frame]  # (H, W) or (H, W, 3)

        # -------- prepare background --------
        if img.ndim == 3 and img.shape[-1] == 3:  #rgb -> luminance
            gray_img = rgb2gray(img)
        else:  #already grayscale
            gray_img = img.astype(np.float32)
            gray_img /= gray_img.max() or 1  # normalise 0‑1
        overlay = label2rgb(
            mask,  # keep IDs intact
            image=gray_img,
            bg_label=0,
            alpha=alpha  # transparency
        )
        plt.figure(figsize=(6, 6))
        plt.imshow(overlay)
        plt.axis("off")
        plt.title(f"{mask_p.name} | frame {frame}")
        plt.show()



    # view the first pair
    preview(*pairs[0])
