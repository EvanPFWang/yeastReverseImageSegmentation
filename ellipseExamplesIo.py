import imageio
import numpy as np, seaborn as sns
from numpy import ndarray
from sklearn.cluster import MiniBatchKMeans
from skimage.color import lab2rgb
from skimage.draw import ellipse



import os
import cv2
import time
import math

import tifffile as tiff
import matplotlib.pyplot as plt
from skimage.color import label2rgb  #nice categorical colouring
from skimage.color import rgb2gray
from pathlib import Path

print("Done Importing")

notebook_directory = os.getcwd()

print(f"Notebook directory: {notebook_directory}")


_DOUBLE_EPS  = np.finfo(np.float64).eps     # ≈ 2.22e‑16
_DOUBLE_TINY = np.finfo(np.float64).tiny    # ≈ 2.23e‑308


import os
import json
import time
from typing import Tuple, Dict, Any

import cv2
import imageio
import numpy as np

"""ellipseExamplesIo.py

Routines for saving, loading, visualising and benchmarking the label
images generated by *EllipseGeneralForm*.  These helpers depend on the core
functions living in the companion module (see `ellipse_params_to_general_form`,
`create_ellipse_mask_vectorized`, `create_ellipse_mask_mathematical`, and
`generate_uint8_labels`).
"""
#If you saved the core under a module name, replace
#the relative import accordingly.

# The following imports assume this helper lives in the same package / notebook
# as the previously‑defined numerical core


from  ellipseMath import (
    ellipse_params_to_general_form,
    create_ellipse_mask_vectorized_perturbed,
    generate_uint8_labels,
    generate_uint8_labels_cv2,
)

__all__ = [
    "save_uint8_labels",
    "load_uint8_labels",
    "visualize_uint8_labels",
    #"compare_mask_generation_methods", removed
    "complete_pipeline",
    "inspect_uint8_output",
    "generate_uint8_labels_cv2",
]


#                                                                           -
# I/O HELPERS
#                                                                           -

def save_uint8_labels(uint8_labels: np.ndarray,dimensions,offset, base_filename: str) -> Dict[str, Any]:
    """Save a uint8 label map in four companion formats.

    1. Raw binary (`*.uint8`)
    2. NumPy array (`*.npy`)
    3. 8‑bit PNG (`*_labels.png`)
    4. JSON metadata (`*_metadata.json`)

    Parameters

    uint8_labels : np.ndarray, dtype ``np.uint8``
        The label image to write.
    base_filename : str
        Path *without* extension; the four outputs will append their own
        extensions as shown above.
    """
    if uint8_labels.dtype != np.uint8:
        raise TypeError("uint8_labels must be of dtype uint8")

    # 1 — raw canvased  binary
    uint8_labels.tofile(f"{base_filename}.uint8")
    print(f"Saved raw binary: {base_filename}.uint8")

    # 2 — NumPy .npy
    np.save(f"{base_filename}.npy", uint8_labels)
    print(f"Saved NumPy array: {base_filename}.npy")

    # 3 — PNG (palettised if desired)
    imageio.imwrite(f"{base_filename}_labels.png", uint8_labels)
    print(f"Saved PNG: {base_filename}_labels.png")

    # 4 — simple metadata
    metadata: Dict[str, Any] = {
        "width": dimensions[0],
        "height": dimensions[1],
        "dtype": "uint8",
        "unique_labels": np.unique(uint8_labels).tolist(),
        "max_label": int(uint8_labels.max()),
        "offset": offset
    }
    with open(f"{base_filename}_metadata.json", "w", encoding="utf-8") as f:
        json.dump(metadata, f, indent=2)
    print(f"Saved metadata: {base_filename}_metadata.json")

    return metadata


def load_uint8_labels(filename: str, width: int, height: int) -> np.ndarray:
    """Load a raw ``*.uint8`` file previously written by
    :func:`save_uint8_labels`.
    """
    flat_array = np.fromfile(filename, dtype=np.uint8)
    return flat_array.reshape((height, width))

def n_spaced_rgb(n:int=9):
    rng = np.random.default_rng(n)
    lab = rng.uniform([0, -40, -40],  # L* ≥ 0
                      [100, 40, 40],  # cut a*,b* to a sensible gamut‑like cube
                      size=(5000, 3))
    k = MiniBatchKMeans(n_clusters=n, batch_size=1536).fit(lab)

    # lab2rgb clips automatically when clip=True; no warning when input is valid
    rgb = np.clip(lab2rgb(k.cluster_centers_[None])[0], 0.0, 1.0)
    return  (rgb * 255).astype(np.uint8)
_DEFAULT_COLORS = n_spaced_rgb()
print(_DEFAULT_COLORS)

def visualize_uint8_labels(uint8_labels: np.ndarray,    metadata:   Dict) -> np.ndarray:
    """Turn a label map into an RGB image using a lookup table.
    Extra labels beyond the length of the palette receive random colours.
    """

    label_idx,width,height   =   metadata["unique_labels"], metadata["width"], metadata["height"]
    colormap = n_spaced_rgb(len(label_idx))

    if colormap is None:
        colormap = _DEFAULT_COLORS.copy()

    max_label = int(uint8_labels.max())
    if max_label >= len(colormap):
        n_extra = max_label + 1 - len(colormap)
        extra = np.random.randint(50, 256, (n_extra, 3), dtype=np.uint8)
        colormap = np.vstack([colormap, extra])

    return colormap[uint8_labels]


#                                                                           -
# BENCHMARK / DEMO UTILITIES
#                                                                           -

#unnecessary after using theese to test ellipses
"""
def _mask_pair(w: int, h: int, center_x: float, center_y: float, a: float, b: float, angle: float):
    coeffs = ellipse_params_to_general_form(center_x, center_y, a, b, angle)
    mask_math = create_ellipse_mask_mathematical(w, h, coeffs)
    mask_vec  = create_ellipse_mask_vectorized(w, h, coeffs)
    return mask_math, mask_vec


def compare_mask_generation_methods() -> None:
    Benchmark pixel‑loop vs. vectorised mask generators for a single ellipse.

    w, h = 128, 128
    center_x, center_y = 64, 64
    a, b = 20, 15
    angle = 30

    print("=== Comparing Ellipse Mask Generation Methods ===")
    print(f"Image size: {w}x{h}")
    print(f"Ellipse: center=({center_x},{center_y}), axes=({a},{b}), rotation={angle}°")

    start = time.time()
    mask_math, mask_vec = _mask_pair(w, h, center_x, center_y, a, b, angle)
    identical = np.array_equal(mask_math, mask_vec)
    print(f"\nMasks identical: {identical}")
    if not identical:
        diff = int((mask_math ^ mask_vec).sum())
        print(f"  Differences: {diff} pixels")

"""

def complete_pipeline() -> Tuple[np.ndarray, np.ndarray]:
    """Run the full generate -> save -> visualise pipeline on a toy dataset."""
    w, h = 128, 500
    cells_data = {
        "indices":       list(range(1, 10)),
        "fluorescence":  [100, 120, 80, 150, 90, 110, 130, 140, 95],
        "size":          [15, 18, 14, 20, 16, 17, 19, 18, 15],
        "shape":         [(8, 7), (10, 9), (7, 7), (11, 10), (9, 8),
                           (9, 9), (10, 8), (9, 9), (8, 7)],
        "location":      [(30, 25), (30, 50), (40, 80), (60, 30),
                           (85, 70), (110, 25), (110, 85), (110, 110), (80, 110)],
        "rotation":      [0, 15, -20, 30, 0, 45, -10, 0, 25],
    }

    print("=== STEP 1: Generate canvas of uint8 labels ===")
    uint8_labels,   dimensions,    offset = generate_uint8_labels(w, h, cells_data)

    print("\n=== STEP 2: Save uint8 labels ===")
    metadata    =   save_uint8_labels(uint8_labels, dimensions, offset, "dump0\canvased_yeast_segmentation")
    cropped_uint8_labels  =   canvas_slicer(uint8_labels, dimensions, offset)

    save_uint8_labels(cropped_uint8_labels, dimensions, offset, "dump0\cropped_yeast_segmentation")

    print("\n=== STEP 3: Visualise ===")
    rgb_vis = visualize_uint8_labels(cropped_uint8_labels,metadata)
    imageio.imwrite("yeast_segmentation_visual.png", rgb_vis)
    print("Saved visualisation: yeast_segmentation_visual.png")

    return cropped_uint8_labels, rgb_vis

def canvas_slicer(canvas:   np.ndarray,dimensions:tuple,offset) -> np.ndarray:
    row_off, col_off = offset[0], offset[1]
    raster_h, raster_w = dimensions[0], dimensions[1]
    cropped =   canvas[row_off: row_off + raster_h,
                  col_off: col_off + raster_w]
    return cropped

def inspect_uint8_output(uint8_labels: np.ndarray) -> None:
    """Pretty‑print basic stats and a small patch of a label image."""
    print("=== Uint8 Label Array Inspection ===")
    print(f"Shape        : {uint8_labels.shape}")
    print(f"Data type    : {uint8_labels.dtype}")
    print(f"Memory       : {uint8_labels.nbytes} bytes")
    print(f"Min | Max    : {uint8_labels.min()} | {uint8_labels.max()}")

    unique, counts = np.unique(uint8_labels, return_counts=True)
    print("\nPixel counts per label:")
    for label, count in zip(unique, counts):
        tag = "Background" if label == 0 else f"Cell {label}"
        print(f"  {tag:11}: {count} px")

    print("\nSample (top‑left 10×10) of raw values:")
    print(uint8_labels[:10, :10])


#                                                                           -
# OpenCV‑BASED FAST FILL HELPER
#                                                                           -






if __name__ == "__main__":
    print("Running quick smoke tests for ellipse I/O + visualisation module…\n")

    # 1. Benchmark mathematical vs. vectorised
#    compare_mask_generation_methods()

    # 2. Full pipeline on toy dataset
    labels, rgb = complete_pipeline()
    inspect_uint8_output(labels)
    print("Demo RGB image saved as demo_labels_vis.png\n")
    #no more need for cv2
    """
    # 3. CV2 generator sanity check
    cv2_cells = {
        "indices": [1],
        "fluorescence": [0],
        "shape": [(25, 18)],
        "location": [(64, 64)],
        "rotation": [45],
    }
    cv2_labels,dimensions,offset = generate_uint8_labels_cv2(128, 128, cv2_cells)
    print("OpenCV generator produced label with unique values:", np.unique(cv2_labels))
    inspect_uint8_output(cv2_labels)
    print("All tests completed successfully.")
    """



    root = Path.cwd()  # same as os.getcwd()
    data_dir = root / "gold-standard-PhC-plus-2"  # cross‑platform join
    assert data_dir.is_dir(), f"{data_dir} does not exist"

    all_tifs = sorted(
        p for p in data_dir.glob("*.tif")  # pathlib.glob ≈ glob.glob
        if p.is_file()
    )
    print(f"Found {len(all_tifs)} TIFFs")

    # Ensure we have an even number of files
    if len(all_tifs) % 2:
        raise ValueError("Uneven number of TIFFs – check your directory!")

    pairs = [
        (all_tifs[i], all_tifs[i + 1])  # (mask, image)
        for i in range(0, len(all_tifs), 2)
    ]

    for mask_path, img_path in pairs:
        print("MASK :", mask_path.name)
        print("IMAGE:", img_path.name)
        # ─── load & process here ───


    def preview(mask_p, img_p, frame=0, alpha=0.4):
        # -------- load one frame --------
        mask = tiff.imread(mask_p)[frame]  # (H, W)  integer labels
        img = tiff.imread(img_p)[frame]  # (H, W) or (H, W, 3)

        # -------- prepare background --------
        if img.ndim == 3 and img.shape[-1] == 3:  #rgb -> luminance
            gray_img = rgb2gray(img)
        else:  #already grayscale
            gray_img = img.astype(np.float32)
            gray_img /= gray_img.max() or 1  # normalise 0‑1
        overlay = label2rgb(
            mask,  # keep IDs intact
            image=gray_img,
            bg_label=0,
            alpha=alpha  # transparencenter_y
        )

        overlay = np.clip(overlay, 0, 1)

        plt.figure(figsize=(6, 6))
        plt.imshow(overlay)
        plt.axis("off")
        plt.title(f"{mask_p.name} | frame {frame}")
        plt.show()



    # view the first pair
    preview(*pairs[0])
